\chapter{Source Code}
\scriptsize
\begin{verbatimtab}[4]

%% Import data from text file.
% Script for importing data from the following text file:
%
%    /Users/FieryCloud/Documents/190/Data/EIL51.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.
% Auto-generated by MATLAB on 2019/08/27 21:27:15
%% Initialize variables.
filename = '/Users/FieryCloud/Documents/190/Data/EIL51.csv';
delimiter = ' ';

%% Format string for each line of text:
%   column1: double (%f)
%	column2: double (%f)
%   column3: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true,  'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
a = dataArray{:, 1};
b = dataArray{:, 2};
c = dataArray{:, 3};


%% Clear temporary variables
clearvars filename delimiter formatSpec fileID dataArray ans;



%% count the number of cities from data and save them in a variable
si=size(c);
si=si(1,1);


%% initialize variables and parameters to be used
param=0.2; %the beta parameter for the selection process
q=5;       %the number of elitist members to be chosen
optimumArray=0; %temporary variable for the array of optimum values per generation
pop_size = 100; %initialize population size
maxGen = 1000; %the maximum number of generations to be done

pop_temp= zeros (pop_size,si);  %temporary initialization for the population

%initializing the population by randomizing based on the cities
for y = 1:1:pop_size
pop_temp(y,:)= randperm(si,si);  
end

%run for 100 times

%save the population on a new variable
pop = pop_temp;

%% solving for the fitness of each individual
fit= zeros (1, pop_size);
for y= 1:1:pop_size
for x=1:1:si
if x==si
fit(1,y)= fit(1,y) + ((b(pop(y,x)) - b(pop(y,1)))^(2) + (c(pop(y,x)) - c (pop(y,1)))^2)^(0.5);
else
fit(1,y)= fit(1,y) + ((b(pop(y,x)) - b(pop(y,(x+1))))^(2) + (c(pop(y,x)) - c (pop(y,(x+1))))^2)^(0.5);
end

end

end

%% sorting from best to least fit
sort_pop= cat(2,pop,(fit.'));
sort_pop= sortrows(sort_pop,(si+1));
optimum= sort_pop(1,si+1);
pop= sort_pop(:,1:si);
optimumArray(1) = optimum; %save the best gene in the array 

%% Compute for selection probabilities
fitval= zeros (pop_size,2);
fitprob= zeros (pop_size,2);

for ctr=1:1:pop_size
fitval(ctr,1) = param * ((1-param)^(ctr-1));
fitval(ctr,2) = (pop_size - ctr + 1)/ pop_size;
end

sfit=sum(fitval);

temp_sum1=0;
temp_sum2=0;


for ctr=1:1:pop_size
temp_sum1 = temp_sum1 + (fitval(ctr,1));
fitprob(ctr,1)= temp_sum1/sfit(1);

temp_sum2 = temp_sum2 + (fitval(ctr,2));
fitprob(ctr,2)= temp_sum2/sfit(2);
end


% We will start with 2, as the first generation to be considered is the
% one from the initial population
gen=2; 

%% Run the whole GA until terminating condition is satisfied.
% Terminating condition is the number of generations.
while gen <= maxGen

offspring= zeros((pop_size*2),si); %initialize temporary offpspring

%% selection process
rep=1;
while rep < (pop_size*2)
if mod(gen,2)==1
ctr=1;
par1=rand;

while par1 > fitprob(ctr,1)
ctr=ctr+1;
end
par1=pop(ctr,:);

ctr=1;
par2=rand;

while par2 > fitprob(ctr,1)
ctr=ctr+1;
end
par2=pop(ctr,:);

else
ctr=1;
par1=rand;

while par1 > fitprob(ctr,2)
ctr=ctr+1;
end
par1= pop(ctr,:);

ctr=1;
par2=rand;

while par2 > fitprob(ctr,2)
ctr=ctr+1;
end
par2=pop(ctr,:);
end

%% crossover
e_num=size(par1);
e_count= e_num(1,2);
c1=zeros(e_num);
c2=zeros(e_num);
c3=zeros(e_num);
c4=zeros(e_num);

position=randperm((e_count-1),2);

if position(1)>position(2)
p1=position(2);
mut_rate=position(1);
else
mut_rate=position(2);
p1=position(1);
end

b_sec1= par2(1:p1);
b_sec2= par2((p1+1):mut_rate);
b_sec3= par2(mut_rate+1:e_count);

mid_count= size(b_sec2);
m_c= mid_count(1,2);
r_c= e_count-m_c;

a_sec1= par1(1:p1);
a_sec2= par1((p1+1):mut_rate);
a_sec3= par1(mut_rate+1:e_count);

b_temp1= [b_sec3,b_sec1,b_sec2];
a_temp1= [a_sec3,a_sec1,a_sec2];

point= mut_rate+1;


checker= ismember(b_temp1,a_sec2);
for ctr=1:1:e_count

if checker(ctr)==0
if point>e_count
point=1;
c1(point)=b_temp1(ctr);
point=point+1;
else
c1(point)=b_temp1(ctr);
point=point+1;
end
else
end
end


for ctr=(p1+1):1:mut_rate
c1(ctr)= par1(ctr); 
end
offspring(rep,:)=c1;
rep=rep+1;

point=mut_rate+1;

checker= ismember(a_temp1,b_sec2);
for ctr=1:1:e_count

if checker(ctr)==0
if point>e_count
point=1;
c2(point)=a_temp1(ctr);
point=point+1;
else
c2(point)=a_temp1(ctr);
point=point+1;
end
else
end
end


for ctr=(p1+1):1:mut_rate
c2(ctr)= par2(ctr); 
end
offspring(rep,:)=c2;
rep=rep+1;

b_temp1= [b_sec2,b_sec1,b_sec3];
a_temp1= [a_sec2,a_sec1,a_sec3];


checker= ismember(b_temp1,a_sec3);

point=1;
for ctr=1:1:e_count
if checker(ctr)==0
c3(point)= b_temp1(ctr);
point=point+1;
else
end
end

for point=(mut_rate+1):1:e_count
c3(point)=par1(point); 
end

offspring(rep,:)=c3;
rep=rep+1;

checker= ismember(a_temp1,b_sec3);

point=1;
for ctr=1:1:e_count
if checker(ctr)==0
c4(point)= a_temp1(ctr);
point=point+1;
else
end
end

for point=(mut_rate+1):1:e_count
c4(point)=par2(point); 
end
offspring(rep,:)=c4;
rep=rep+1;
end

%% compute for the path length of each individual
fit= zeros (1, (pop_size*2));
for y= 1:1:(pop_size*2)
for x=1:1:si
if x==si
fit(1,y)= fit(1,y) + ((b(offspring(y,x)) - b(offspring(y,1)))^(2) + (c(offspring(y,x)) - c (offspring(y,1)))^2)^(0.5);
else
fit(1,y)= fit(1,y) + ((b(offspring(y,x)) - b(offspring(y,(x+1))))^(2) + (c(offspring(y,x)) - c (offspring(y,(x+1))))^2)^(0.5);
end
end
end

%% merge the q individuals and the 2n offspring and sort
sort_off= cat(2,offspring,(fit.'));

merge=cat(1,sort_pop(1:q,:),sort_off(:,:));

sort_gen= sortrows(merge,(si+1));

sort_fitness = sort_gen(:, (si+1));

numberOf = numel(sort_fitness);

%% compute for the mutation rate
fitnessAverage = sum(sort_fitness)/205;
mut_rate = (1 - ((fitnessAverage - sort_fitness(1))/sort_fitness(1)));

%% Mutation process
for ctr=1:1:(pop_size*2)
m=rand;

if m<mut_rate
mut= offspring(ctr,:);
e_num= size(mut);
e_count=e_num(1,2);

position=randperm((e_count-1),2);

if position(1)>position(2)
p1=position(2);
mut_rate=position(1);
else
mut_rate=position(2);
p1=position(1);
end

sec1= mut(1:p1);
sec2= mut((p1+1):mut_rate);
sec3= mut(mut_rate+1:e_count);

sec_flip= flip(sec2);

offspring(ctr,:)= [sec1,sec_flip,sec3];

else


end
end

%% Recompute fitness values
fit= zeros (1, (pop_size*2));
for y= 1:1:(pop_size*2)
for x=1:1:si
if x==si
fit(1,y)= fit(1,y) + ((b(offspring(y,x)) - b(offspring(y,1)))^(2) + (c(offspring(y,x)) - c (offspring(y,1)))^2)^(0.5);
else
fit(1,y)= fit(1,y) + ((b(offspring(y,x)) - b(offspring(y,(x+1))))^(2) + (c(offspring(y,x)) - c (offspring(y,(x+1))))^2)^(0.5);
end

end

end    

%% Create new population. Merge the 2n mutated and unmutated offspring, and the q
% individuals. Sort them and select the n highest individuals.
sort_off2= cat(2,offspring,(fit.'));

merge= cat(1,sort_gen(1:q,:),sort_off2(:,:));

sort_gen= sortrows(merge,(si+1));

pop = sort_gen(1:pop_size,1:si);

sort_pop = sort_gen(1:100,:);

optimum = sort_gen(1,(si+1)); %the optimum path length for current generation

pop_ave = sum(sort_pop(:, (si+1)))/100;

pop_ave_array_MOGA2(gen)= pop_ave; 

optimumArray(gen) = optimum; %the array holding optimum path length per generation

gen=gen+1; %increment for the number of generations

graphSol = pop(1,:); %the array holding the best individual (sequence of cities)
end

%% graphing the path taken of best individual
hold on
for x = 1:1:(si-1)

plot([ b(graphSol(x)) b(graphSol(x+1))], [c(graphSol(x)) c(graphSol(x+1))]);

end
plot([ b(graphSol(si)) b(graphSol(1))], [c(graphSol(si)) c(graphSol(1))]);
\end{verbatimtab}
\normalsize